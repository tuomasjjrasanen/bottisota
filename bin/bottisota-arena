#!/usr/bin/env python3

import errno
import itertools
import logging
import logging.handlers
import math
import os
import random
import signal
import socket
import sys
import time

import bottisota
import bottisota.bus
import bottisota.math
import bottisota.protocol

logger = logging.getLogger("bottisota")
logger.setLevel(logging.INFO)

logger.addHandler(logging.StreamHandler(sys.stderr))
logger.handlers[0].setFormatter(logging.Formatter("%(levelname)s|%(name)s|%(asctime)s|%(message)s"))

battle_logger = logging.getLogger("bottisota.battle")
battle_logger.addHandler(logging.StreamHandler(sys.stdout))

def randpos():
    x = random.randint(0, bottisota.ARENA_WIDTH - 1)
    y = random.randint(0, bottisota.ARENA_HEIGHT - 1)
    direction = random.randint(0, 359)

    return (x, y), direction

class Clock:

    def __init__(self):
        self.__ticks = 0

    def tick(self):
        self.__ticks += 1
        battle_logger.info("tick %d", self.__ticks)
        time.sleep(bottisota.TICK_MS / 1000)

    def now(self):
        return self.__ticks

CLOCK = Clock()

class Missile:

    next_idnum = 1

    def __init__(self, loc, speed, direction, distance):
        self.idnum = Missile.next_idnum
        Missile.next_idnum += 1
        self.ticks_since_last_update = 1
        self.x, self.y = loc
        self.direction = direction % 360
        self.distance_remaining = distance
        self.speed = speed
        self.next_speed = bottisota.MSL_SPEED

    @property
    def loc(self):
        return (self.x, self.y)

    def update_position(self):
        distance = min(self.distance_remaining, self.speed * self.ticks_since_last_update)
        self.distance_remaining = max(0, self.distance_remaining - distance)
        direction_rad = math.radians(self.direction)
        dy = round(math.sin(direction_rad) * distance)
        dx = round(math.cos(direction_rad) * distance)
        if dx or dy:
            new_x, new_y = (self.x + dx, self.y + dy)
            if new_x < 0 or new_x >= bottisota.ARENA_WIDTH or new_y < 0 or new_y >= bottisota.ARENA_HEIGHT:
                new_x = min(max(new_x, 0), bottisota.ARENA_WIDTH - 1)
                new_y = min(max(new_y, 0), bottisota.ARENA_HEIGHT - 1)
                self.next_speed = bottisota.DRV_SPEED_MIN
                self.distance_remaining = 0
            self.x = new_x
            self.y = new_y

        self.speed = self.next_speed

    def damage(self, target_bot):
        if self.distance_remaining:
            # Still flying.
            return

        explosion_distance = bottisota.math.distance(self.loc, target_bot.loc)

        if explosion_distance == 0:
            damage = 25
        elif explosion_distance > 40:
            damage = 0
        else:
            damage = min(25, math.floor(1 / (explosion_distance / 150)))

        target_bot.add_damage(damage)

    def is_scrap(self):
        return not self.distance_remaining

    def log_status(self):
        if not self.distance_remaining:
            battle_logger.info("missile %d exploded at %d, %d", self.idnum, self.x, self.y)
        else:
            battle_logger.info("missile %d at %d, %d, direction to %d, speed %d", self.idnum, self.x, self.y, self.direction, self.speed)

class Controller:

    def __init__(self, sock, idnum):
        self.__conn = bottisota.bus.ArenaConnection(sock)
        self.__syscall = None
        self.__ticks_since_last_update = 1
        self.__err = None
        self.bot = Bot(idnum)
        self.missiles = []

        self.__read_syscall_methods = {
            bottisota.protocol.SYSCALL_POS_FUN: self.__read_syscall_pos,
            bottisota.protocol.SYSCALL_CLK_FUN: self.__read_syscall_clk,
            bottisota.protocol.SYSCALL_DRV_FUN: self.__read_syscall_drv,
            bottisota.protocol.SYSCALL_SCN_FUN: self.__read_syscall_scn,
            bottisota.protocol.SYSCALL_MSL_FUN: self.__read_syscall_msl,
        }

        self.__return_syscall_methods = {
            bottisota.protocol.SYSCALL_POS_FUN: self.__return_syscall_pos,
            bottisota.protocol.SYSCALL_CLK_FUN: self.__return_syscall_clk,
            bottisota.protocol.SYSCALL_DRV_FUN: self.__return_syscall_drv,
            bottisota.protocol.SYSCALL_SCN_FUN: self.__return_syscall_scn,
            bottisota.protocol.SYSCALL_MSL_FUN: self.__return_syscall_msl,
        }

    def shutdown(self):
        self.__conn.disconnect()

    def __read_syscall_pos(self):
        self.__err = bottisota.protocol.ERR_OK

    def __read_syscall_clk(self):
        self.__err = bottisota.protocol.ERR_OK

    def __read_syscall_drv(self):
        direction, speed = self.__syscall[1]
        if speed > bottisota.DRV_SPEED_MAX:
            self.__err = bottisota.protocol.ERR_BADARG
        else:
            self.__err = bottisota.protocol.ERR_OK
            self.bot.speed = speed
            self.bot.direction = direction % 360

    def __read_syscall_scn(self):
        direction, resolution = self.__syscall[1]
        if resolution > bottisota.SCN_RESOLUTION_MAX:
            self.__err = bottisota.protocol.ERR_BADARG
        else:
            self.__err = bottisota.protocol.ERR_OK
            self.bot.scn_direction = direction % 360
            self.bot.scn_resolution = resolution
            self.bot.scn_distance = 0
            self.bot.scn_idnum = 0
            self.bot.scn_on = True

    def __read_syscall_msl(self):
        direction, distance = self.__syscall[1]
        if distance > bottisota.MSL_DISTANCE_MAX:
            self.__err = bottisota.protocol.ERR_BADARG
        else:
            self.__err = bottisota.protocol.ERR_OK
            missile = self.bot.launch_missile(direction, distance)
            self.missiles.append(missile)

    def read_syscall(self):
        self.__syscall = self.__conn.recv(False)

        if not self.__syscall:
            return

        self.__err = bottisota.protocol.ERR_UNKNOWN
        self.__read_syscall_methods[self.__syscall[0]]()

    def __return_syscall_pos(self):
        return self.bot.pos

    def __return_syscall_clk(self):
        return CLOCK.now(),

    def __return_syscall_drv(self):
        return self.bot.speed,

    def __return_syscall_scn(self):
        scn_distance = self.bot.scn_distance
        scn_idnum = self.bot.scn_idnum
        self.bot.scn_distance = 0
        self.bot.scn_idnum = 0
        self.bot.scn_resolution = 0
        self.bot.scn_direction = 0
        self.bot.scn_on = False

        return scn_distance, scn_idnum

    def __return_syscall_msl(self):
        return ()

    def return_syscall(self):
        if self.__syscall:
            return_values = self.__return_syscall_methods[self.__syscall[0]]()
            self.__conn.send(self.__syscall[0].replace("?", "="), self.__err, *return_values)
            self.__syscall = None

    def log_status(self):
        for missile in self.missiles:
            missile.log_status()

        self.bot.log_status()

    def remove_scrap(self):
        scrap_missiles = []

        for missile in self.missiles:
            if missile.is_scrap():
                scrap_missiles.append(missile)

        for scrap_missile in scrap_missiles:
            self.missiles.remove(scrap_missile)

class Bot:

    def __init__(self, idnum):
        loc, direction = randpos()

        self.idnum = idnum
        self.x, self.y = loc
        self.direction = direction
        self.speed = bottisota.DRV_SPEED_MIN
        self.health = bottisota.HEALTH_MAX

        self.scn_direction = 0
        self.scn_resolution = 0
        self.scn_distance = 0
        self.scn_idnum = 0
        self.scn_on = False

        self.ticks_since_last_update = 1

    @property
    def loc(self):
        return (self.x, self.y)

    @property
    def pos(self):
        return self.x, self.y, self.speed, self.direction

    def update_position(self):
        distance = self.speed * self.ticks_since_last_update
        direction_rad = math.radians(self.direction)
        dy = round(math.sin(direction_rad) * distance)
        dx = round(math.cos(direction_rad) * distance)
        if dx or dy:
            new_x, new_y = (self.x + dx, self.y + dy)
            if new_x < 0 or new_x >= bottisota.ARENA_WIDTH or new_y < 0 or new_y >= bottisota.ARENA_HEIGHT:
                new_x = min(max(new_x, 0), bottisota.ARENA_WIDTH - 1)
                new_y = min(max(new_y, 0), bottisota.ARENA_HEIGHT - 1)
                self.speed = bottisota.DRV_SPEED_MIN
            self.x = new_x
            self.y = new_y

    def update_scan(self, target):
        if not self.scn_on:
            return

        target_distance = bottisota.math.distance(self.loc, target.loc)
        if target_distance > bottisota.SCN_DISTANCE:
            return

        target_direction = bottisota.math.direction(self.loc, target.loc)
        left_bound = (self.scn_direction - self.scn_resolution) % 360
        right_bound = (self.scn_direction + self.scn_resolution) % 360
        if left_bound <= target_direction <= right_bound:
            distance_min = max(target_distance - bottisota.SCN_ERROR_PER_RESOLUTION * self.scn_resolution, 0)
            distance_max = min(target_distance + bottisota.SCN_ERROR_PER_RESOLUTION * self.scn_resolution, bottisota.SCN_DISTANCE)
            self.scn_distance = random.randint(round(distance_min), round(distance_max))
            self.scn_idnum = target.idnum

    def log_status(self):
        battle_logger.info("bot %d at %d, %d, direction to %d, speed %d, health %d", self.idnum, self.x, self.y, self.direction, self.speed, self.health)
        if self.scn_on:
            battle_logger.info("bot %d scanning direction %dÂ±%d", self.idnum, self.scn_direction, self.scn_resolution)

    def launch_missile(self, direction, distance):
        missile = Missile(self.loc, self.speed, direction, distance)
        missile.log_status()
        return missile

    def is_scrap(self):
        return self.health == bottisota.HEALTH_MIN

    def add_damage(self, damage):
        self.health = max(bottisota.HEALTH_MIN, self.health - damage)

class Battle:

    def __init__(self):
        self.__controllers = []
        self.__is_on = True

    def wait_for_controller(self, arenasock):
        controllersock = arenasock.accept()[0]
        idnum = len(self.__controllers) + 1

        logger.info("connection %d established", idnum)

        controller = Controller(controllersock, idnum)
        self.__controllers.append(controller)
        controller.log_status()

    def stop(self, signum, stack_frame):
        self.__is_on = False

    def play(self):
        initial_controller_count = len(self.__controllers)
        battle_logger.info("begin")
        try:
            while len(self.__controllers) == initial_controller_count and self.__is_on:
                CLOCK.tick()
                self.__read_syscalls()
                self.__update()
                self.__log_status()
                self.__return_syscalls()
                self.__remove_scrap()

        finally:
            battle_logger.info("end")
            first_error = sys.exc_info()[1]
            while self.__controllers:
                controller = self.__controllers.pop()
                try:
                    controller.shutdown()
                except Exception as e:
                    first_error = first_error or e
                    continue

            if first_error:
                raise first_error

    def iter_bots(self):
        for controller in self.__controllers:
            yield controller.bot

    def iter_missiles(self):
        for controller in self.__controllers:
            for missile in controller.missiles:
                yield missile

    def __update_positions(self):
        # TODO: dynamic collision detection
        for bot in self.iter_bots():
            bot.update_position()

        for missile in self.iter_missiles():
            missile.update_position()

    def __update_damages(self):
        for missile in self.iter_missiles():
            for bot in self.iter_bots():
                missile.damage(bot)

    def __update_scans(self):
        for scanning_bot, scanned_bot in itertools.permutations(self.iter_bots(), 2):
            scanning_bot.update_scan(scanned_bot)

    def __remove_scrap(self):
        for controller in self.__controllers:
            controller.remove_scrap()

    def __update(self):
        self.__update_positions()
        self.__update_damages()
        self.__update_scans()

    def __log_status(self):
        for controller in self.__controllers:
            controller.log_status()

    def __read_syscalls(self):
        failed_controllers = []

        for controller in self.__controllers:
            try:
                controller.read_syscall()
            except:
                logger.exception("failed to read a syscall from a controller")
                failed_controllers.append(controller)

        for failed_controller in failed_controllers:
            self.__controllers.remove(failed_controller)
            try:
                failed_controller.shutdown()
            except:
                logger.exception("failed to shutdown a failed controller")
                continue

    def __return_syscalls(self):
        for controller in self.__controllers:
            controller.return_syscall()

class Arena:

    def __init__(self, address=bottisota.bus.ADDRESS):
        self.__address = address
        self.__sock = None
        self.__monitor_sock = None

    def __enter__(self):
        sock = socket.socket(socket.AF_UNIX)

        try:
            os.remove(self.__address)
        except OSError as e:
            if e.errno != errno.ENOENT:
                raise

        try:
            sock.bind(self.__address)
            sock.listen(2)
        except:
            sock.close()
            os.remove(self.__address)
            raise

        self.__sock = sock
        return self

    def __exit__(self, *args):
        sock = self.__sock
        self.__sock = None

        first_error = None

        try:
            os.remove(sock.getsockname())
        except Exception as e:
            first_error = first_error or e

        try:
            sock.close()
        except Exception as e:
            first_error = first_error or e

        if first_error:
            raise first_error

    def run(self):
        battle = Battle()

        battle_logger.info("init")

        battle.wait_for_controller(self.__sock)
        battle.wait_for_controller(self.__sock)

        signal.signal(signal.SIGUSR1, battle.stop)
        signal.signal(signal.SIGUSR2, battle.stop)
        signal.signal(signal.SIGALRM, battle.stop)
        signal.signal(signal.SIGHUP, battle.stop)
        signal.signal(signal.SIGINT, battle.stop)
        signal.signal(signal.SIGTERM, battle.stop)

        battle.play()

def main():
    with Arena() as arena:
        arena.run()

if __name__ == "__main__":
    main()
