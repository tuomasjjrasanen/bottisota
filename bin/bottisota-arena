#!/usr/bin/env python3

import errno
import itertools
import logging
import logging.handlers
import math
import os
import random
import signal
import socket
import sys
import time

import bottisota
import bottisota.bus
import bottisota.math
import bottisota.protocol

logger = logging.getLogger("bottisota")
logger.setLevel(logging.INFO)

logger.addHandler(logging.StreamHandler(sys.stderr))
logger.handlers[0].setFormatter(logging.Formatter("%(levelname)s|%(name)s|%(asctime)s|%(message)s"))

battle_logger = logging.getLogger("bottisota.battle")
battle_logger.addHandler(logging.StreamHandler(sys.stdout))

class Clock:

    def __init__(self):
        self.__ticks = 0

    def tick(self):
        self.__ticks += 1
        battle_logger.info("tick %d", self.__ticks)
        time.sleep(bottisota.TICK_MS / 1000)

    def now(self):
        return self.__ticks

CLOCK = Clock()

class Thing:

    _next_idnum = 1

    def __init__(self, x, y, health):
        self.idnum = self.__class__._get_next_idnum()
        self.x = x
        self.y = y
        self.__health = health

    @property
    def health(self):
        return self.__health

    @property
    def loc(self):
        return self.x, self.y

    @classmethod
    def _get_next_idnum(cls):
        next_idnum = cls._next_idnum
        cls._next_idnum += 1
        return next_idnum

    def destroy(self):
        self.add_damage(self.health)

    def is_destroyed(self):
        return self.health == 0

    def add_damage(self, damage):
        self.__health = max(0, self.health - damage)

    def status_line(self):
        return "x %d, y %d, health %d" % (self.x, self.y, self.health)

    def log_status(self):
        battle_logger.info("%s %d: %s", self.__class__.__name__, self.idnum, self.status_line())

class MovableThing(Thing):

    def __init__(self, x, y, health, direction, initial_speed, target_speed):
        super().__init__(x, y, health)
        self.__speed = initial_speed
        self.__target_speed = target_speed
        self.__direction = direction % 360

    def drive(self, speed, direction):
        self.__target_speed = speed
        self.__direction = direction % 360

    @property
    def direction(self):
        return self.__direction

    @property
    def speed(self):
        return self.__speed

    def _move_by(self, distance):
        direction_rad = math.radians(self.direction)
        dy = round(math.sin(direction_rad) * distance)
        dx = round(math.cos(direction_rad) * distance)
        if dx or dy:
            new_x, new_y = (self.x + dx, self.y + dy)
            if new_x < 0 or new_x >= bottisota.ARENA_WIDTH or new_y < 0 or new_y >= bottisota.ARENA_HEIGHT:
                new_x = min(max(new_x, 0), bottisota.ARENA_WIDTH - 1)
                new_y = min(max(new_y, 0), bottisota.ARENA_HEIGHT - 1)
                self.__target_speed = bottisota.DRV_SPEED_MIN
            self.x = new_x
            self.y = new_y

        self.__speed = self.__target_speed

    def move(self):
        self._move_by(self.speed * 1)

    def status_line(self):
        return super().status_line() + ", direction %d, speed %d" % (self.direction, self.speed)

class Missile(MovableThing):

    def __init__(self, x, y, speed, direction, distance):
        super().__init__(x, y, distance, direction, speed, bottisota.MSL_SPEED)

    def _move_by(self, distance):
        distance = min(self.health, distance)
        super()._move_by(distance)
        self.add_damage(distance)
        if self.speed == 0:
            self.destroy()

    def inflict_damage(self, target_things):
        if not self.is_destroyed():
            # Still flying.
            return

        for target_thing in target_things:
            explosion_distance = bottisota.math.distance(self.loc, target_thing.loc)

            if explosion_distance == 0:
                damage = 25
            elif explosion_distance > 40:
                damage = 0
            else:
                damage = min(25, math.floor(1 / (explosion_distance / 150)))

            target_thing.add_damage(damage)

class Bot(MovableThing):

    def __init__(self, x, y, direction):
        super().__init__(x, y, bottisota.HEALTH_MAX, direction, bottisota.DRV_SPEED_MIN, bottisota.DRV_SPEED_MIN)

        self.__scn_direction = 0
        self.__scn_resolution = 0
        self.__scn_distance = 0
        self.__scn_idnum = 0

    def scan(self, target_bot):
        if self.__scn_resolution == 0:
            return

        target_distance = bottisota.math.distance(self.loc, target_bot.loc)
        if target_distance > bottisota.SCN_DISTANCE:
            return

        target_direction = bottisota.math.direction(self.loc, target_bot.loc)
        left_bound = (self.__scn_direction - self.__scn_resolution) % 360
        right_bound = (self.__scn_direction + self.__scn_resolution) % 360
        if left_bound <= target_direction <= right_bound:
            distance_min = max(target_distance - bottisota.SCN_ERROR_PER_RESOLUTION * self.__scn_resolution, 0)
            distance_max = min(target_distance + bottisota.SCN_ERROR_PER_RESOLUTION * self.__scn_resolution, bottisota.SCN_DISTANCE)
            self.__scn_distance = random.randint(round(distance_min), round(distance_max))
            self.__scn_idnum = target_bot.idnum

    def status_line(self):
        return super().status_line() + ", scan %dÂ±%d" % (self.__scn_direction, self.__scn_resolution)

    def launch_missile(self, direction, distance):
        missile = Missile(self.x, self.y, self.speed, direction, distance)
        missile.log_status()
        return missile

    def start_scan(self, direction, resolution):
        self.__scn_direction = direction % 360
        self.__scn_resolution = resolution
        self.__scn_distance = 0
        self.__scn_idnum = 0

    def stop_scan(self):
        scn_distance = self.__scn_distance
        scn_idnum = self.__scn_idnum
        self.__scn_distance = 0
        self.__scn_idnum = 0
        self.__scn_resolution = 0
        self.__scn_direction = 0

        return scn_distance, scn_idnum

class Controller:

    def __init__(self, sock, idnum):
        self.__conn = bottisota.bus.ArenaConnection(sock)
        self.__syscall = None
        self.__err = None
        x, y, = bottisota.math.randloc()
        direction = bottisota.math.randdirection()
        self.bot = Bot(x, y, direction)
        self.missiles = []

        self.__read_syscall_methods = {
            bottisota.protocol.SYSCALL_POS_FUN: self.__read_syscall_pos,
            bottisota.protocol.SYSCALL_CLK_FUN: self.__read_syscall_clk,
            bottisota.protocol.SYSCALL_DRV_FUN: self.__read_syscall_drv,
            bottisota.protocol.SYSCALL_SCN_FUN: self.__read_syscall_scn,
            bottisota.protocol.SYSCALL_MSL_FUN: self.__read_syscall_msl,
        }

        self.__return_syscall_methods = {
            bottisota.protocol.SYSCALL_POS_FUN: self.__return_syscall_pos,
            bottisota.protocol.SYSCALL_CLK_FUN: self.__return_syscall_clk,
            bottisota.protocol.SYSCALL_DRV_FUN: self.__return_syscall_drv,
            bottisota.protocol.SYSCALL_SCN_FUN: self.__return_syscall_scn,
            bottisota.protocol.SYSCALL_MSL_FUN: self.__return_syscall_msl,
        }

    def shutdown(self):
        self.__conn.disconnect()

    def __read_syscall_pos(self):
        self.__err = bottisota.protocol.ERR_OK

    def __read_syscall_clk(self):
        self.__err = bottisota.protocol.ERR_OK

    def __read_syscall_drv(self):
        direction, speed = self.__syscall[1]
        if speed > bottisota.DRV_SPEED_MAX:
            self.__err = bottisota.protocol.ERR_BADARG
        else:
            self.__err = bottisota.protocol.ERR_OK
            self.bot.drive(speed, direction)

    def __read_syscall_scn(self):
        direction, resolution = self.__syscall[1]
        if bottisota.SCN_RESOLUTION_MIN > resolution > bottisota.SCN_RESOLUTION_MAX:
            self.__err = bottisota.protocol.ERR_BADARG
        else:
            self.__err = bottisota.protocol.ERR_OK
            self.bot.start_scan(direction, resolution)

    def __read_syscall_msl(self):
        direction, distance = self.__syscall[1]
        if distance > bottisota.MSL_DISTANCE_MAX:
            self.__err = bottisota.protocol.ERR_BADARG
        else:
            self.__err = bottisota.protocol.ERR_OK
            missile = self.bot.launch_missile(direction, distance)
            self.missiles.append(missile)

    def read_syscall(self):
        self.__syscall = self.__conn.recv(False)

        if not self.__syscall:
            return

        self.__err = bottisota.protocol.ERR_UNKNOWN
        self.__read_syscall_methods[self.__syscall[0]]()

    def __return_syscall_pos(self):
        return self.bot.x, self.bot.y, self.bot.speed, self.bot.direction

    def __return_syscall_clk(self):
        return CLOCK.now(),

    def __return_syscall_drv(self):
        return self.bot.speed,

    def __return_syscall_scn(self):
        return self.bot.stop_scan()

    def __return_syscall_msl(self):
        return ()

    def return_syscall(self):
        if self.__syscall:
            return_values = self.__return_syscall_methods[self.__syscall[0]]()
            self.__conn.send(self.__syscall[0].replace("?", "="), self.__err, *return_values)
            self.__syscall = None

    def log_status(self):
        for missile in self.missiles:
            missile.log_status()

        self.bot.log_status()

    def remove_destroyed_things(self):
        destroyed_missiles = []

        for missile in self.missiles:
            if missile.is_destroyed():
                destroyed_missiles.append(missile)

        for destroyed_missile in destroyed_missiles:
            self.missiles.remove(destroyed_missile)

class Battle:

    def __init__(self):
        self.__controllers = []
        self.__is_on = True

    def wait_for_controller(self, arenasock):
        controllersock = arenasock.accept()[0]
        idnum = len(self.__controllers) + 1

        logger.info("connection %d established", idnum)

        controller = Controller(controllersock, idnum)
        self.__controllers.append(controller)
        controller.log_status()

    def stop(self, signum, stack_frame):
        self.__is_on = False

    def play(self):
        initial_controller_count = len(self.__controllers)
        battle_logger.info("begin")
        try:
            while len(self.__controllers) == initial_controller_count and self.__is_on:
                CLOCK.tick()
                self.__read_syscalls()
                self.__update()
                self.__log_status()
                self.__return_syscalls()
                self.__remove_destroyed_things()

        finally:
            battle_logger.info("end")
            first_error = sys.exc_info()[1]
            while self.__controllers:
                controller = self.__controllers.pop()
                try:
                    controller.shutdown()
                except Exception as e:
                    first_error = first_error or e
                    continue

            if first_error:
                raise first_error

    def iter_bots(self):
        for controller in self.__controllers:
            yield controller.bot

    def iter_missiles(self):
        for controller in self.__controllers:
            for missile in controller.missiles:
                yield missile

    def __move_things(self):
        # TODO: dynamic collision detection
        for bot in self.iter_bots():
            bot.move()

        for missile in self.iter_missiles():
            missile.move()

    def __update_damages(self):
        for missile in self.iter_missiles():
            missile.inflict_damage(self.iter_bots())

    def __update_scan_results(self):
        for scanning_bot, scanned_bot in itertools.permutations(self.iter_bots(), 2):
            scanning_bot.scan(scanned_bot)

    def __remove_destroyed_things(self):
        for controller in self.__controllers:
            controller.remove_destroyed_things()

    def __update(self):
        self.__move_things()
        self.__update_damages()
        self.__update_scan_results()

    def __log_status(self):
        for controller in self.__controllers:
            controller.log_status()

    def __read_syscalls(self):
        failed_controllers = []

        for controller in self.__controllers:
            try:
                controller.read_syscall()
            except:
                logger.exception("failed to read a syscall from a controller")
                failed_controllers.append(controller)

        for failed_controller in failed_controllers:
            self.__controllers.remove(failed_controller)
            try:
                failed_controller.shutdown()
            except:
                logger.exception("failed to shutdown a failed controller")
                continue

    def __return_syscalls(self):
        for controller in self.__controllers:
            controller.return_syscall()

class Arena:

    def __init__(self, address=bottisota.bus.ADDRESS):
        self.__address = address
        self.__sock = None
        self.__monitor_sock = None

    def __enter__(self):
        sock = socket.socket(socket.AF_UNIX)

        try:
            os.remove(self.__address)
        except OSError as e:
            if e.errno != errno.ENOENT:
                raise

        try:
            sock.bind(self.__address)
            sock.listen(2)
        except:
            sock.close()
            os.remove(self.__address)
            raise

        self.__sock = sock
        return self

    def __exit__(self, *args):
        sock = self.__sock
        self.__sock = None

        first_error = None

        try:
            os.remove(sock.getsockname())
        except Exception as e:
            first_error = first_error or e

        try:
            sock.close()
        except Exception as e:
            first_error = first_error or e

        if first_error:
            raise first_error

    def run(self):
        battle = Battle()

        battle.wait_for_controller(self.__sock)
        battle.wait_for_controller(self.__sock)

        signal.signal(signal.SIGUSR1, battle.stop)
        signal.signal(signal.SIGUSR2, battle.stop)
        signal.signal(signal.SIGALRM, battle.stop)
        signal.signal(signal.SIGHUP, battle.stop)
        signal.signal(signal.SIGINT, battle.stop)
        signal.signal(signal.SIGTERM, battle.stop)

        battle.play()

def main():
    with Arena() as arena:
        arena.run()

if __name__ == "__main__":
    main()
