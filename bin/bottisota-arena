#!/usr/bin/env python3

import errno
import itertools
import logging
import logging.handlers
import math
import os
import random
import signal
import socket
import sys
import time

import bottisota
import bottisota.bus
import bottisota.math
import bottisota.protocol

logger = logging.getLogger("bottisota")
logger.setLevel(logging.INFO)

logger.addHandler(logging.StreamHandler(sys.stderr))
logger.handlers[0].setFormatter(logging.Formatter("%(levelname)s|%(name)s|%(asctime)s|%(message)s"))

battle_logger = logging.getLogger("bottisota.battle")
battle_logger.addHandler(logging.StreamHandler(sys.stdout))

def randpos():
    x = random.randint(0, bottisota.ARENA_WIDTH)
    y = random.randint(0, bottisota.ARENA_HEIGHT)
    direction = random.randint(0, 359)

    return (x, y), direction

class Clock:

    def __init__(self):
        self.__ticks = 0

    def tick(self):
        self.__ticks += 1
        battle_logger.info("tick %d", self.__ticks)
        time.sleep(bottisota.TICK_MS / 1000)

    def now(self):
        return self.__ticks

CLOCK = Clock()

class Controller:

    def __init__(self, sock, idnum):
        self.__conn = bottisota.bus.ArenaConnection(sock)
        self.__syscall = None
        self.__ticks_since_last_update = 1
        self.__err = None
        self.__idnum = idnum
        self.bot = Bot(idnum)

        self.__read_syscall_methods = {
            bottisota.protocol.SYSCALL_POS_FUN: self.__read_syscall_pos,
            bottisota.protocol.SYSCALL_CLK_FUN: self.__read_syscall_clk,
            bottisota.protocol.SYSCALL_DRV_FUN: self.__read_syscall_drv,
            bottisota.protocol.SYSCALL_SCN_FUN: self.__read_syscall_scn,
        }

        self.__return_syscall_methods = {
            bottisota.protocol.SYSCALL_POS_FUN: self.__return_syscall_pos,
            bottisota.protocol.SYSCALL_CLK_FUN: self.__return_syscall_clk,
            bottisota.protocol.SYSCALL_DRV_FUN: self.__return_syscall_drv,
            bottisota.protocol.SYSCALL_SCN_FUN: self.__return_syscall_scn,
        }

    def shutdown(self):
        self.__conn.disconnect()

    def __read_syscall_pos(self):
        self.__err = bottisota.protocol.ERR_OK

    def __read_syscall_clk(self):
        self.__err = bottisota.protocol.ERR_OK

    def __read_syscall_drv(self):
        speed, direction = self.__syscall[1]
        if speed > bottisota.DRV_SPEED_MAX:
            self.__err = bottisota.protocol.ERR_BADARG
        else:
            self.__err = bottisota.protocol.ERR_OK
            self.bot.speed = speed
            self.bot.direction = direction % 360

    def __read_syscall_scn(self):
        direction, resolution = self.__syscall[1]
        if resolution > bottisota.SCN_RESOLUTION_MAX:
            self.__err = bottisota.protocol.ERR_BADARG
        else:
            self.__err = bottisota.protocol.ERR_OK
            self.bot.scn_direction = direction % 360
            self.bot.scn_resolution = resolution
            self.bot.scn_distance = 0
            self.bot.scn_on = True

    def read_syscall(self):
        self.__syscall = self.__conn.recv(False)

        if not self.__syscall:
            return

        self.__err = bottisota.protocol.ERR_UNKNOWN
        self.__read_syscall_methods[self.__syscall[0]]()

    def __return_syscall_pos(self):
        return self.bot.pos

    def __return_syscall_clk(self):
        return CLOCK.now(),

    def __return_syscall_drv(self):
        return ()

    def __return_syscall_scn(self):
        scn_distance = self.bot.scn_distance
        self.bot.scn_distance = 0
        self.bot.scn_resolution = 0
        self.bot.scn_direction = 0
        self.bot.scn_on = False

        return scn_distance,

    def return_syscall(self):
        if self.__syscall:
            return_values = self.__return_syscall_methods[self.__syscall[0]]()
            self.__conn.send(self.__syscall[0].replace("?", "="), self.__err, *return_values)
            self.__syscall = None

    def log_status(self):
        self.bot.log_status()

class Bot:

    def __init__(self, idnum):
        loc, direction = randpos()

        self.idnum = idnum
        self.x, self.y = loc
        self.direction = direction
        self.speed = bottisota.DRV_SPEED_MIN
        self.damage = bottisota.DAMAGE_MIN

        self.scn_direction = 0
        self.scn_resolution = 0
        self.scn_distance = 0
        self.scn_on = False

        self.ticks_since_last_update = 1

    @property
    def loc(self):
        return (self.x, self.y)

    @property
    def pos(self):
        return self.x, self.y, self.speed, self.direction

    def update_position(self):
        distance = self.speed * self.ticks_since_last_update
        direction_rad = math.radians(self.direction)
        dy = int(round(math.sin(direction_rad) * distance))
        dx = int(round(math.cos(direction_rad) * distance))
        if dx or dy:
            new_x, new_y = (self.x + dx, self.y + dy)
            if new_x < 0 or new_x > bottisota.ARENA_WIDTH or new_y < 0 or new_y > bottisota.ARENA_HEIGHT:
                new_x = min(max(new_x, 0), bottisota.ARENA_WIDTH)
                new_y = min(max(new_y, 0), bottisota.ARENA_HEIGHT)
                self.speed = bottisota.DRV_SPEED_MIN
            self.x = new_x
            self.y = new_y

    def update_scan(self, target):
        if not self.scn_on:
            return

        target_distance = bottisota.math.distance(self.loc, target.loc)
        if target_distance > bottisota.SCN_DISTANCE:
            return

        target_direction = bottisota.math.direction(self.loc, target.loc)
        left_bound = (self.scn_direction - self.scn_resolution) % 360
        right_bound = (self.scn_direction + self.scn_resolution) % 360
        if left_bound <= target_direction <= right_bound:
            distance_min = max(target_distance - bottisota.SCN_ERROR_PER_RESOLUTION * self.scn_resolution, 0)
            distance_max = min(target_distance + bottisota.SCN_ERROR_PER_RESOLUTION * self.scn_resolution, bottisota.SCN_DISTANCE)
            self.scn_distance = random.randint(round(distance_min), round(distance_max))

    def log_status(self):
        battle_logger.info("bot %d at %d, %d, direction to %d, speed %d, damage %d", self.idnum, self.x, self.y, self.direction, self.speed, self.damage)
        if self.scn_on:
            battle_logger.info("bot %d scanning direction %dÂ±%d", self.idnum, self.scn_direction, self.scn_resolution)

class Battle:

    def __init__(self):
        self.__controllers = []
        self.__is_on = True

    def wait_for_controller(self, arenasock):
        controllersock = arenasock.accept()[0]
        idnum = len(self.__controllers) + 1

        logger.info("connection %d established", idnum)

        controller = Controller(controllersock, idnum)
        self.__controllers.append(controller)
        controller.log_status()

    def stop(self, signum, stack_frame):
        self.__is_on = False

    def play(self):
        initial_controller_count = len(self.__controllers)
        battle_logger.info("begin")
        try:
            while len(self.__controllers) == initial_controller_count and self.__is_on:
                CLOCK.tick()
                self.__read_syscalls()
                self.__update()
                self.__log_status()
                self.__return_syscalls()

        finally:
            battle_logger.info("end")
            first_error = sys.exc_info()[1]
            while self.__controllers:
                controller = self.__controllers.pop()
                try:
                    controller.shutdown()
                except Exception as e:
                    first_error = first_error or e
                    continue

            if first_error:
                raise first_error

    def __update_positions(self):
        # TODO: dynamic collision detection
        for controller in self.__controllers:
            controller.bot.update_position()

    def __update_scans(self):
        for scanning_bot, scanned_bot in itertools.permutations([c.bot for c in self.__controllers], 2):
            scanning_bot.update_scan(scanned_bot)

    def __update(self):
        self.__update_positions()
        self.__update_scans()

    def __log_status(self):
        for controller in self.__controllers:
            controller.log_status()

    def __read_syscalls(self):
        failed_controllers = []

        for controller in self.__controllers:
            try:
                controller.read_syscall()
            except:
                logger.exception("failed to read a syscall from a controller")
                failed_controllers.append(controller)

        for failed_controller in failed_controllers:
            self.__controllers.remove(failed_controller)
            try:
                failed_controller.shutdown()
            except:
                logger.exception("failed to shutdown a failed controller")
                continue

    def __return_syscalls(self):
        for controller in self.__controllers:
            controller.return_syscall()

class Arena:

    def __init__(self, address=bottisota.bus.ADDRESS):
        self.__address = address
        self.__sock = None
        self.__monitor_sock = None

    def __enter__(self):
        sock = socket.socket(socket.AF_UNIX)

        try:
            os.remove(self.__address)
        except OSError as e:
            if e.errno != errno.ENOENT:
                raise

        try:
            sock.bind(self.__address)
            sock.listen(2)
        except:
            sock.close()
            os.remove(self.__address)
            raise

        self.__sock = sock
        return self

    def __exit__(self, *args):
        sock = self.__sock
        self.__sock = None

        first_error = None

        try:
            os.remove(sock.getsockname())
        except Exception as e:
            first_error = first_error or e

        try:
            sock.close()
        except Exception as e:
            first_error = first_error or e

        if first_error:
            raise first_error

    def run(self):
        battle = Battle()

        battle_logger.info("init")

        battle.wait_for_controller(self.__sock)
        battle.wait_for_controller(self.__sock)

        signal.signal(signal.SIGUSR1, battle.stop)
        signal.signal(signal.SIGUSR2, battle.stop)
        signal.signal(signal.SIGALRM, battle.stop)
        signal.signal(signal.SIGHUP, battle.stop)
        signal.signal(signal.SIGINT, battle.stop)
        signal.signal(signal.SIGTERM, battle.stop)

        battle.play()

def main():
    with Arena() as arena:
        arena.run()

if __name__ == "__main__":
    main()
