#!/usr/bin/env python3

import errno
import itertools
import logging
import logging.handlers
import math
import os
import random
import signal
import socket
import sys
import time

import bottisota
import bottisota.bus
import bottisota.math
import bottisota.protocol

logger = logging.getLogger("bottisota")
logger.setLevel(logging.INFO)

logger.addHandler(logging.StreamHandler(sys.stderr))
logger.handlers[0].setFormatter(logging.Formatter("%(levelname)s|%(name)s|%(asctime)s|%(message)s"))

battle_logger = logging.getLogger("bottisota.battle")
battle_logger.addHandler(logging.StreamHandler(sys.stdout))

def randpos():
    x = random.randint(bottisota.X_MIN, bottisota.X_MAX)
    y = random.randint(bottisota.Y_MIN, bottisota.Y_MAX)
    direction = random.randint(0, 359)

    return (x, y), direction

class Clock:

    def __init__(self):
        self.__ticks = 0

    def tick(self):
        self.__ticks += 1
        battle_logger.info("tick %d", self.__ticks)
        time.sleep(bottisota.TICK_MILLIS / 1000)

    def now(self):
        return self.__ticks

CLOCK = Clock()

class Bot:

    def __init__(self, sock, idnum, loc, direction):
        self.__conn = bottisota.bus.ArenaConnection(sock)
        self.__syscall = None
        self.__ticks_since_last_update = 1
        self.__err = None

        self.__idnum = idnum
        self.__x, self.__y = loc
        self.__direction = direction
        self.__speed = bottisota.DRV_SPEED_MIN

        self.__scn_direction = 0
        self.__scn_resolution = 0
        self.__scn_distance = 0
        self.__scn_on = False

        self.__read_syscall_methods = {
            bottisota.protocol.SYSCALL_POS_FUN: self.__read_syscall_pos,
            bottisota.protocol.SYSCALL_CLK_FUN: self.__read_syscall_clk,
            bottisota.protocol.SYSCALL_DRV_FUN: self.__read_syscall_drv,
            bottisota.protocol.SYSCALL_SCN_FUN: self.__read_syscall_scn,
        }

        self.__return_syscall_methods = {
            bottisota.protocol.SYSCALL_POS_FUN: self.__return_syscall_pos,
            bottisota.protocol.SYSCALL_CLK_FUN: self.__return_syscall_clk,
            bottisota.protocol.SYSCALL_DRV_FUN: self.__return_syscall_drv,
            bottisota.protocol.SYSCALL_SCN_FUN: self.__return_syscall_scn,
        }

    @property
    def idnum(self):
        return self.__idnum

    @property
    def loc(self):
        return (self.__x, self.__y)

    @property
    def direction(self):
        return self.__direction

    @property
    def speed(self):
        return self.__speed

    def shutdown(self):
        self.__conn.disconnect()

    def __read_syscall_pos(self):
        self.__err = bottisota.protocol.ERR_OK

    def __read_syscall_clk(self):
        self.__err = bottisota.protocol.ERR_OK

    def __read_syscall_drv(self):
        speed, direction = self.__syscall[1]
        if speed > bottisota.DRV_SPEED_MAX:
            self.__err = bottisota.protocol.ERR_BADARG
        else:
            self.__err = bottisota.protocol.ERR_OK
            self.__speed = speed
            self.__direction = direction % 360

    def __read_syscall_scn(self):
        direction, resolution = self.__syscall[1]
        if resolution > bottisota.SCN_RESOLUTION_MAX:
            self.__err = bottisota.protocol.ERR_BADARG
        else:
            self.__err = bottisota.protocol.ERR_OK
            self.__scn_direction = direction % 360
            self.__scn_resolution = resolution
            self.__scn_distance = 0
            self.__scn_on = True

    def read_syscall(self):
        self.__syscall = self.__conn.recv(False)
        self.__err = bottisota.protocol.ERR_UNKNOWN

        self.__read_syscall_methods[self.__syscall[0]]()

    def __return_syscall_pos(self):
        return self.__x, self.__y, self.__speed, self.__direction

    def __return_syscall_clk(self):
        return CLOCK.now(),

    def __return_syscall_drv(self):
        return self.__err,

    def __return_syscall_scn(self):
        scn_distance = self.__scn_distance
        self.__scn_distance = 0
        self.__scn_resolution = 0
        self.__scn_direction = 0
        self.__scn_on = False

        return scn_distance,

    def return_syscall(self):
        return_values = self.__return_syscall_methods[self.__syscall[0]]()
        self.__conn.send(self.__syscall[0].replace("?", "="), self.__err, *return_values)
        self.__syscall = None

    def update_position(self):
        distance = self.__speed * self.__ticks_since_last_update
        direction_rad = math.radians(self.__direction)
        dy = int(round(math.sin(direction_rad) * distance))
        dx = int(round(math.cos(direction_rad) * distance))
        if dx or dy:
            new_x, new_y = (self.__x + dx, self.__y + dy)
            if new_x < bottisota.X_MIN or new_x > bottisota.X_MAX or new_y < bottisota.Y_MIN or new_y > bottisota.Y_MAX:
                new_x = min(max(new_x, bottisota.X_MIN), bottisota.X_MAX)
                new_y = min(max(new_y, bottisota.Y_MIN), bottisota.Y_MAX)
                self.__speed = bottisota.DRV_SPEED_MIN
            self.__x = new_x
            self.__y = new_y

    def update_scan(self, target):
        if self.__syscall[0] != bottisota.protocol.SYSCALL_SCN_FUN:
            return

        target_distance = bottisota.math.distance(self.loc, target.loc)
        if target_distance > bottisota.SCN_DISTANCE_MAX:
            return

        target_direction = bottisota.math.direction(self.loc, target.loc)
        left_bound = (self.__scn_direction - self.__scn_resolution) % 360
        right_bound = (self.__scn_direction + self.__scn_resolution) % 360
        if left_bound <= target_direction <= right_bound:
            distance_min = max(target_distance - bottisota.SCN_ERROR_PER_RESOLUTION * self.__scn_resolution, bottisota.SCN_DISTANCE_MIN)
            distance_max = min(target_distance + bottisota.SCN_ERROR_PER_RESOLUTION * self.__scn_resolution, bottisota.SCN_DISTANCE_MAX)
            self.__scn_distance = random.randint(round(distance_min), round(distance_max))

    def log_status(self):
        if self.__scn_on:
            battle_logger.info("bot %d at %d, %d, direction to %d, speed %d, scanning direction %dÂ±%d", self.__idnum, self.__x, self.__y, self.__direction, self.__speed, self.__scn_direction, self.__scn_resolution)
        else:
            battle_logger.info("bot %d at %d, %d, direction to %d, speed %d", self.__idnum, self.__x, self.__y, self.__direction, self.__speed)

class Battle:

    def __init__(self):
        self.__bots = []
        self.__is_on = True

    def wait_for_bot(self, arenasock):
        botsock = arenasock.accept()[0]
        idnum = len(self.__bots) + 1

        logger.info("connection %d established", idnum)

        loc, direction = randpos()
        while loc in [b.loc for b in self.__bots]:
            loc, direction = randpos()

        bot = Bot(botsock, idnum, loc, direction)
        self.__bots.append(bot)
        bot.log_status()

    def stop(self, signum, stack_frame):
        self.__is_on = False

    def play(self):
        initial_bot_count = len(self.__bots)
        battle_logger.info("begin")
        try:
            while len(self.__bots) == initial_bot_count and self.__is_on:
                CLOCK.tick()
                self.__read_syscalls()
                self.__update()
                self.__log_status()
                self.__return_syscalls()

        finally:
            battle_logger.info("end")
            first_error = sys.exc_info()[1]
            while self.__bots:
                bot = self.__bots.pop()
                try:
                    bot.shutdown()
                except Exception as e:
                    first_error = first_error or e
                    continue

            if first_error:
                raise first_error

    def __update_positions(self):
        # TODO: dynamic collision detection
        for bot in self.__bots:
            bot.update_position()

    def __update_scans(self):
        for scanning_bot, scanned_bot in itertools.permutations(self.__bots, 2):
            scanning_bot.update_scan(scanned_bot)

    def __update(self):
        self.__update_positions()
        self.__update_scans()

    def __log_status(self):
        for bot in self.__bots:
            bot.log_status()

    def __read_syscalls(self):
        failed_bots = []

        for bot in self.__bots:
            try:
                bot.read_syscall()
            except:
                logger.exception("failed to read a syscall from a bot")
                failed_bots.append(bot)

        for failed_bot in failed_bots:
            self.__bots.remove(failed_bot)
            try:
                failed_bot.shutdown()
            except:
                logger.exception("failed to shutdown a failed bot")
                continue

    def __return_syscalls(self):
        for bot in self.__bots:
            bot.return_syscall()

class Arena:

    def __init__(self, address=bottisota.bus.ADDRESS):
        self.__address = address
        self.__sock = None
        self.__monitor_sock = None

    def __enter__(self):
        sock = socket.socket(socket.AF_UNIX)

        try:
            os.remove(self.__address)
        except OSError as e:
            if e.errno != errno.ENOENT:
                raise

        try:
            sock.bind(self.__address)
            sock.listen(2)
        except:
            sock.close()
            os.remove(self.__address)
            raise

        self.__sock = sock
        return self

    def __exit__(self, *args):
        sock = self.__sock
        self.__sock = None

        first_error = None

        try:
            os.remove(sock.getsockname())
        except Exception as e:
            first_error = first_error or e

        try:
            sock.close()
        except Exception as e:
            first_error = first_error or e

        if first_error:
            raise first_error

    def run(self):
        battle = Battle()

        battle_logger.info("init")

        battle.wait_for_bot(self.__sock)
        battle.wait_for_bot(self.__sock)

        signal.signal(signal.SIGUSR1, battle.stop)
        signal.signal(signal.SIGUSR2, battle.stop)
        signal.signal(signal.SIGALRM, battle.stop)
        signal.signal(signal.SIGHUP, battle.stop)
        signal.signal(signal.SIGINT, battle.stop)
        signal.signal(signal.SIGTERM, battle.stop)

        battle.play()

def main():
    with Arena() as arena:
        arena.run()

if __name__ == "__main__":
    main()
